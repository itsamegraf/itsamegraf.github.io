/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/vecn@1.3.1/src/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
let e=new Proxy({},{get:function(e,t){return e.hasOwnProperty(t)||(e[t]=i(t)),e[t]}});class t extends Array{constructor(e,t){if(!(t=m(t)).every((e=>"Number"===a(e))))throw new TypeError("All arguments must be numbers.");if(t.length>1&&t.length!==e)throw new Error("Argument list must be empty, have a single number, or have a length equal to the dimension.");0===t.length&&(t=[0]),1===t.length&&"Number"===a(t[0])&&(t=Array(e).fill(t[0])),e>1?super(...t):(super(1),this[0]=t[0]),Reflect.defineProperty(this,"pop",{value:void 0,enumerable:!1}),Reflect.defineProperty(this,"push",{value:void 0,enumerable:!1}),Reflect.defineProperty(this,"shift",{value:void 0,enumerable:!1}),Reflect.defineProperty(this,"unshift",{value:void 0,enumerable:!1})}get magnitude(){return this.pnorm(2)}div(t){o(t,this.dim,!0),"Number"===a(t)&&(t=new Array(this.dim).fill(t));let r=[];for(let e=0;e<this.length;++e)r[e]=this[e]/t[e];return e[this.dim](r)}minus(t){o(t,this.dim,!0),"Number"===a(t)&&(t=new Array(this.dim).fill(t));let r=[];for(let e=0;e<this.dim;++e)r[e]=this[e]-t[e];return e[this.dim](r)}neg(){return e[this.dim](this.times(-1))}plus(t){o(t,this.dim,!0),"Number"===a(t)&&(t=new Array(this.dim).fill(t));let r=[];for(let e=0;e<this.dim;++e)r[e]=this[e]+t[e];return e[this.dim](r)}pow(t){let r=[];for(let e=0;e<this.dim;++e)r[e]=Math.pow(this[e],t);return e[this.dim](r)}times(t){o(t,this.dim,!0),"Number"===a(t)&&(t=new Array(this.dim).fill(t));let r=[];for(let e=0;e<this.dim;++e)r[e]=this[e]*t[e];return e[this.dim](r)}dot(e){o(e,this.dim);let t=0;for(let r=0;r<this.dim;++r)t+=this[r]*e[r];return t}normalize(){return this.div(this.magnitude)}pnorm(e){let t=0;for(let r=0;r<this.dim;++r)t+=Math.pow(Math.abs(this[r]),e);return Math.pow(t,1/e)}reflect(e){const t=e.normalize();return this.minus(t.times(2*this.dot(t)))}argmax(){const e=this.max();return this.reduce(((t,r,i)=>r===e?t.concat([i]):t),[])}argmin(){const e=this.min();return this.reduce(((t,r,i)=>r===e?t.concat([i]):t),[])}choose(t){if(!Array.isArray(t))throw new TypeError("Argument must be a list of indices.");if(!t.every((e=>e<this.dim&&u(e.toString()))))throw new RangeError("All elements of argument must be valid indices.");let r=[];return t.forEach((e=>r.push(this[e]))),e[r.length](r)}copy(){return e[this.dim](this)}equals(e){return e.length===this.dim&&e.every(((e,t)=>this[t]===e))}approximatelyEquals(e,t=1e-8){return e.length===this.dim&&e.every(((e,r)=>Math.abs(this[r]-e)<t))}max(){return Math.max(...this)}min(){return Math.min(...this)}sum(){return this.reduce(((e,t)=>e+t),0)}toArray(){return Array.from(this)}concat(...t){const r=super.concat.apply(this.toArray(),t);return e[r.length](r)}filter(...t){const r=super.filter.apply(this.toArray(),t);return r.length>0?e[r.length](r):r}map(...e){const t=super.map(...e);return t.every((e=>"Number"===a(e)))?t:t.toArray()}slice(...t){const r=super.slice.apply(this.toArray(),t);return r.length>0?e[r.length](r):r}splice(...e){let t=this.toArray();if(t.splice(...e),t.length!==this.dim)throw new Error("All removed elements must be replaced.");if(!t.every((e=>"Number"===a(e))))throw new TypeError("All elements must be numbers.");t.forEach(((e,t)=>{this[t]=e}))}toString(){return this.reduce(((e,t,r)=>e+t+(r===this.dim-1?" ":", ")),"[ ")+"]"}}const r={set:function(e,t,r){if("length"===t)return!1;if(u(t)){if(Number(t)>=e.dim)throw new RangeError("Vector may not have more elements than dimension.");if("Number"!==a(r))throw new TypeError("Vectors may only contain numbers.");return e[t]=r,!0}const i=s(t.toString());return!!(e.dim<=4&&i)&&(function(e,t,r,i){if(1===t.length){if("Number"!==a(i))throw new TypeError("Must set to a number");return void(e[r[t]]=i)}if(!Array.isArray(i))throw new TypeError("Right-hand side must be an array.");if(t.length!==i.length)throw new TypeError("Right-hand side must have matching length.");if(!i.every((e=>"Number"===a(e))))throw new TypeError("All new values must be numbers.");if(t.split("").some((t=>r[t]>=e.dim)))return;let n=!0;for(let e=0,r={};e<t.length;++e){if(r.hasOwnProperty(t[e])){n=!1;break}r[t[e]]=!0}if(!n)throw new SyntaxError("Swizzle assignment does not allow symbols to be repeated.");t.split("").map((e=>r[e])).forEach(((t,r)=>{e[t]=i[r]}))}(e,t.toString(),i,r),!0)},get:function(t,r){const i=s(r.toString());return t.dim<=4&&i?function(t,r,i){const n=r.length;if(1===n)return t[i[r]];let s=r.split("").reduce(((e,r)=>{let n=i[r];return e&&n<t.dim?e.concat([t[n]]):void 0}),[]);return s?new e[n](...s):void 0}(t,r,i):t[r]}};function i(i){if(!((i=Number(i))in e)){if(isNaN(i))throw new TypeError("Dimension must be coercible to a number.");if(i<=0)throw new RangeError("Dimension must be positive.");if(!Number.isInteger(i))throw new RangeError("Dimension must be positive.");let n="vec"+i,s={[n]:class extends t{constructor(...e){if(1===e.length&&e[0]instanceof t){if(e[0].dim>i)throw new TypeError("Cannot demote vectors.");e=function(e,t){return[...Array(t)].map(((t,r)=>r<e.length?e[r]:0))}(e[0].toArray(),i)}super(i,e),Reflect.defineProperty(this,"dim",{value:i,writable:!1,enumerable:!1})}}}[n],o=function(...e){let t=new s(...e);return Object.preventExtensions(t),new Proxy(t,r)};e[i]=o}return e[i]}const n=[{x:0,y:1,z:2,w:3},{r:0,g:1,b:2,a:3},{s:0,t:1,p:2,q:3}];function s(e){return n.find((t=>e.split("").every((e=>e in t))))}function o(e,t,r=!1){if(!(r&&"Number"===a(e)||e.length&&e.length===t))throw new TypeError(`Invalid argument. Input must have matching dimension${r?"or be a scalar":""}.`)}function m(e){return e instanceof Array&&1===e.length&&e[0]instanceof Array?m(e[0]):e}function u(e){return!isNaN(e)&&Number(e).toString()===e&&Number.isInteger(Number(e))&&Number(e)>=0}function a(e){return Object.prototype.toString.call(e).slice(8,-1)}var h={getVecType:i,isVec:function(e){return e instanceof t},vec2:e[2],vec3:e[3],vec4:e[4],add:function(...t){const r=t[0].dim;if(!t.every((e=>e.dim===r)))throw new TypeError("All vectors must have the same dimension.");return t.reduce(((e,t)=>e.plus(t)),e[r]())},multiply:function(...t){const r=t[0].dim;if(!t.every((e=>e.dim===r)))throw new TypeError("All vectors must have the same dimension.");return t.reduce(((e,t)=>e.times(t)),e[r](1))},lerp:function(e,t,r){if(e.dim!==t.dim)throw new TypeError("Vectors must have the same dimension.");return r=r<0?0:r>1?1:r,e.plus(t.minus(e).times(r))},slerp:function(e,t,r){if(e.dim!==t.dim)throw new TypeError("Vectors must have the same dimension.");r=r<0?0:r>1?1:r;let i=e.normalize().dot(t.normalize());i=i<-1?-1:i>1?1:i;const n=Math.acos(i)*r,s=t.minus(e.times(i)).normalize(),o=e.magnitude+(t.magnitude-e.magnitude)*r;return e.times(Math.cos(n)).plus(s.times(Math.sin(n))).normalize().times(o)}},l=h.add,c=h.getVecType,d=h.isVec,f=h.lerp,p=h.multiply,y=h.slerp,g=h.vec2,w=h.vec3,b=h.vec4;export{l as add,h as default,c as getVecType,d as isVec,f as lerp,p as multiply,y as slerp,g as vec2,w as vec3,b as vec4};
//# sourceMappingURL=/sm/ed4facd79586acb84e47e2bac534a1fb2b01a242b6c084f81c53b7203729c5a7.map