/**
 * adjusted vecn import
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/bezier-spline@2.0.0/src/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import t from"./vecn.js";var e={exports:{}};const s=t;const r=class{constructor(t){t=t[0].length?t:t.map((t=>[t])),Reflect.defineProperty(this,"length",{value:4,enumerable:!1,writable:!1});for(let e=0;e<this.length;++e)this[e]=Array.from(t[e])}at(t){t=t<0?0:t>1?1:t;let e=s.getVecType(this[0].length),r=[...new Array(4)].map(((t,s)=>e(this[s]))),n=[];return n.push(r[0].times(Math.pow(1-t,3))),n.push(r[1].times(3*Math.pow(1-t,2)*t)),n.push(r[2].times(3*(1-t)*Math.pow(t,2))),n.push(r[3].times(Math.pow(t,3))),s.add(...n).toArray()}solve(t=0,e=0){let s=Array.prototype.map.call(this,(e=>e[t]));return function(t,e,s,r){if(0===t)return function(t,e,s){if(0===t)return function(t,e){if(0===t)return[];return[-e/t]}(e,s);let r=Math.sqrt(e*e-4*t*s),n=(-e-r)/(2*t),h=(-e+r)/(2*t);return[n,h]}(e,s,r);let n=t*e*s*r*18;n-=Math.pow(e,3)*r*4,n+=Math.pow(e,2)*Math.pow(s,2),n-=t*Math.pow(s,3)*4,n-=Math.pow(t,2)*Math.pow(r,2)*27;let h=Math.pow(e,2)-t*s*3;if(0===n){if(0===h){return[-e/(3*t)]}{let n=t*e*s*4;return n-=t*t*r*9,n-=e*e*e,n/=t*h,[n,(t*r*9-e*s)/(2*h)]}}{let n=(s/t*3-Math.pow(e,2)/Math.pow(t,2))/3,h=2*Math.pow(e,3)/Math.pow(t,3);h-=9*e*s/Math.pow(t,2),h+=27*r/t,h/=27;let o=Math.pow(h,2)/4+Math.pow(n,3)/27;if(o>0){let s=-h/2+Math.sqrt(o),r=Math.cbrt(s),n=-h/2-Math.sqrt(o);return[r+Math.cbrt(n)-e/(3*t)]}{let s=Math.sqrt(Math.pow(h,2)/4-o),r=Math.cbrt(s),n=Math.acos(-h/(2*s)),a=-r,i=Math.cos(n/3),p=Math.sqrt(3)*Math.sin(n/3),u=-e/(3*t);return[2*r*Math.cos(n/3)-e/(3*t),a*(i+p)+u,a*(i-p)+u]}}}(-s[0]+3*s[1]-3*s[2]+s[3],3*s[0]-6*s[1]+3*s[2],-3*s[0]+3*s[1],s[0]-e).map((t=>0===t?0:t)).filter((t=>t>=0&&t<=1)).sort()}},n=t;e.exports=class{constructor(t){this.setKnots(t)}recalculate(){const t=this.knots.length;this.curves=[];let e=new Array(t);for(let s=1;s<t-1;++s){let t=this.knots[s].minus(this.knots[s-1]).magnitude,r=this.knots[s+1].minus(this.knots[s]).magnitude;e[s]=t/r}let s=new Array(t-1),h=new Array(t-1),o=new Array(t-1),a=new Array(t-1);s[0]=0,h[0]=2,o[0]=e[1],a[0]=this.knots[0].plus(this.knots[1].times(1+e[1]));for(let r=1;r<t-2;++r)s[r]=1,h[r]=2*(e[r]+e[r]*e[r]),o[r]=e[r+1]*e[r]*e[r],a[r]=this.knots[r].times(1+2*e[r]+e[r]*e[r]).plus(this.knots[r+1].times(1+e[r+1]).times(e[r]*e[r]));s[t-2]=1,h[t-2]=2*e[t-2]+1.5*e[t-2]*e[t-2],o[t-2]=0,a[t-2]=this.knots[t-2].times(1+2*e[t-2]+e[t-2]*e[t-2]).plus(this.knots[t-1].times(.5*e[t-2]*e[t-2]));let i=function(t,e,s,r){const h=r[0].length?r[0].length:1,o=n.getVecType(h),a=r.length;t=t.map((t=>o(t))),e=e.map((t=>o(t))),s=s.map((t=>o(t))),r=r.map((t=>o(t)));let i=[],p=[];p.push(s[0].div(e[0])),i.push(r[0].div(e[0]));for(let n=1;n<a;++n)p.push(s[n].div(e[n].minus(t[n].times(p[n-1])))),i.push(r[n].minus(t[n].times(i[n-1])).div(e[n].minus(t[n].times(p[n-1]))));let u=new Array(a);u[a-1]=i[a-1];for(let t=a-2;t>=0;--t)u[t]=i[t].minus(p[t].times(u[t+1]));return u}(s,h,o,a),p=[];for(let s=0;s<t-2;++s)p.push(this.knots[s+1].minus(i[s+1].minus(this.knots[s+1]).times(e[s+1])));p.push(this.knots[t-1].plus(i[t-2]).times(.5));for(let e=0;e<t-1;++e)this.curves.push(new r([this.knots[e],i[e],p[e],this.knots[e+1]]))}setKnots(t){const e=n.getVecType(t[0].length);t=t.map((t=>e(t))),this.knots=t,this.recalculate()}getPoints(t,e){return this.curves.map((s=>s.solve(t,e).map((t=>s.at(t))))).reduce(((t,e)=>t.concat(e)),[]).reduce(((t,e)=>t.some((t=>t.every(((t,s)=>Math.min(t,e[s])/Math.max(t,e[s])>.999))))?t:t.concat([e])),[]).map((t=>Array.from(t)))}};var h=e.exports.BezierCurve=r,o=e.exports;export{h as BezierCurve,o as default};
//# sourceMappingURL=/sm/070e3165894815345a9c0019930e82106c12d7b4a5db8e477aa66d792fd273a0.map